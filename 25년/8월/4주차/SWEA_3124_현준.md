## 최소스패닝트리([SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV_mSnmKUckDFAWb) 3124)

## 풀이

크루스칼 알고리즘(Kruskal's Algorithm)을 사용한 최소 신장 트리(MST) 구현입니다.

주어진 무방향 가중 그래프에서 모든 정점을 연결하면서 간선의 가중치 합이 최소가 되는 트리를 찾는 문제입니다.

1. 모든 간선을 가중치 기준으로 오름차순 정렬
2. Union-Find 자료구조를 이용해 사이클 여부 검사
3. 사이클을 생성하지 않는 간선들을 선택하여 MST 구성
4. V-1개의 간선을 선택할 때까지 반복

## 해답

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

/*
 * Solution 3124. 최소 스패닝 트리
 * 
 * 메모리: 120,824 KB / 실행시간: 1,539 ms
 * 
 * Kruskal's algorithm
 */
public class Solution_3124_장현준 {
	
	private static int[] parent;
	
	static class Edge implements Comparable<Edge> {
		int from;
		int to;
		int weight;
		
		public Edge(int from, int to, int weight) {
			super();
			this.from = from;
			this.to = to;
			this.weight = weight;
		}

		@Override
		public int compareTo(Edge o) {
			return Integer.compare(this.weight, o.weight);
		}
	}
	
	public static void main(String[] args) throws IOException {
		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
		
		int T = Integer.parseInt(bufferedReader.readLine()); // 전체 test case의 수 T(1≤T≤10)
		
		
		
		for (int t = 1; t <= T; t++) {
			StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
			
			int V = Integer.parseInt(stringTokenizer.nextToken()); // 정점의 개수 V(1≤V≤100,000)
			int E = Integer.parseInt(stringTokenizer.nextToken()); // 간선의 개수 E(1≤E≤200,000)
			
			parent = new int[V + 1]; // 입력 예시 확인 시 정점 번호 1 ~ V 인걸 알 수 있음
			Edge[] edgeList = new Edge[E];
			
			for (int e = 0; e < E; e++) {
				stringTokenizer = new StringTokenizer(bufferedReader.readLine());
				
				int from = Integer.parseInt(stringTokenizer.nextToken());
				int to = Integer.parseInt(stringTokenizer.nextToken());
				int weight = Integer.parseInt(stringTokenizer.nextToken());
				
				edgeList[e] = new Edge(from, to, weight);
			}
			
			Arrays.sort(edgeList); // 간선 가중치 기준으로 오름차순 정렬
			makeSet(V);
			
			long totalWeiht = 0;	// 최소 스패닝 트리의 가중치
			int edgeCount = 0;	// 최소 스패닝 트리의 간선 수 (최대 V - 1 개)
			
			for (Edge edge : edgeList) {
				if (!union(edge.from, edge.to)) { // union 실패
					continue;
				}
				
				totalWeiht += edge.weight;
				edgeCount++;
				
				if (edgeCount == V - 1) {
					break;
				}
			}
			
			System.out.println("#" + t + " " + totalWeiht);
		}
	}
	
	
	private static void makeSet(int V) {
		for (int i = 1; i <= V; i++) { // 정점 번호 1 ~ V
			parent[i] = i;
		}
	}
	
	private static int find(int a) {
		if (parent[a] == a) {
			return a;
		}
		return parent[a] = find(parent[a]);
	}
	
	private static boolean union(int a, int b) {
		int aRoot = find(a);
		int bRoot = find(b);
		
		if (aRoot == bRoot) {
			return false;
		} else if (aRoot > bRoot) {
			parent[bRoot] = aRoot;
		} else {
			parent[aRoot] = bRoot;
		}
		
		return true;
	}
}
```