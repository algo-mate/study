## 하나로([SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15StKqAQkCFAYD) 1251)

## 풀이

크루스칼 알고리즘을 사용한 최소 신장 트리(MST) 문제입니다.

모든 섬을 연결하되 최소 환경 부담금으로 해저터널을 건설하는 문제로, 섬 간의 거리의 제곱에 환경 부담 세율을 곱한 값이 비용이 됩니다.

1. 모든 섬 쌍에 대해 간선 생성 (환경 부담금 = E * 거리^2)
2. 간선들을 비용 기준으로 오름차순 정렬
3. Union-Find 자료구조를 이용해 사이클을 피하면서 최소 비용 간선들을 선택
4. N-1개 간선을 선택하여 모든 섬을 연결하는 MST 구성

## 해답

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

/*
 *  Solution 1251. [S/W 문제해결 응용] 4일차 - 하나로
 *  
 *  메모리: 85,344 KB / 실행시간: 926 ms
 *  
 *  크루스칼
 */
public class Solution_1251_장현준 {
	
	private static int[][] island; 	// 각 섬들의 정수인 X[0], Y[1] 좌표 (0≤X≤1,000,000, 0≤Y≤1,000,000)
	private static double E; 		// 해저터널 건설의 환경 부담 세율 실수 (0≤E≤1)
	private static int[] parent; 	// union find 각 노드의 부모 노드를 저장하는 배열
	private static Edge[] edgeList; // 섬들을 연결하는 간선(해저터널) 정보 리스트
	
	
	// 섬들을 연결하는 간선(해저터널)
	static class Edge implements Comparable<Edge> {
		int from;
		int to;
		double cost; // 환경 부담금
		
		public Edge(int from, int to, double cost) {
			super();
			this.from = from;
			this.to = to;
			this.cost = cost;
		}

		@Override
		public int compareTo(Edge o) {
			return Double.compare(cost, o.cost);
		}
			
	}
	
	
	public static void main(String[] args) throws IOException {
		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
		
		int T = Integer.parseInt(bufferedReader.readLine()); // 전체 테스트 케이스의 수
		
		for (int t = 1; t <= T; t++) {
			int N = Integer.parseInt(bufferedReader.readLine()); //섬의 개수 (1≤N≤1,000)
			
			island = new int[N][2];
			
			// 각 섬들의 정수인 X좌표 입력
			StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
			for (int i = 0; i < N; i++) {
				island[i][0] = Integer.parseInt(stringTokenizer.nextToken());
			}
			
			// 각 섬들의 정수인 Y좌표 입력
			stringTokenizer = new StringTokenizer(bufferedReader.readLine());
			for (int i = 0; i < N; i++) {
				island[i][1] = Integer.parseInt(stringTokenizer.nextToken());
			}
			
			E = Double.parseDouble(bufferedReader.readLine());
			
			// 무방향 그래프 간선의 총 개수 선언.
			edgeList = new Edge[N * (N - 1) / 2];
			
			// 모든 간선 초기화
			for (int edgeIdx = 0, from = 0; from < N - 1; from++) {
				for (int to = from + 1; to < N; to++) {
					double cost = calculationCost(island[from], island[to]);
					edgeList[edgeIdx] = new Edge(from, to, cost);
					edgeIdx++;
				}
			}
			
			// 간선 비용 기준으로 오름차순 정렬
			Arrays.sort(edgeList);
			
			// union-find
			parent = new int[N];
			makeSet(N);
			
			double totalCost = 0; // 모든 섬들을 잇는 최소 환경 부담금 == 최소 신장 트리 비용
			int edgeCount = 0; // 처리된 간선수

			for (Edge edge : edgeList) {
				if (!union(edge.from, edge.to)) { // union 실패 : 싸이클 발생
					continue;
				}
				
				totalCost += edge.cost;
				edgeCount++; 
				
				if (edgeCount == N - 1) { // 최소 신장 트리 간선 수 == N - 1 
					break;
				}
			}
			
			// 모든 섬들을 잇는 최소 환경 부담금을 소수 첫째 자리에서 반올림하여 정수 형태로 출력
			System.out.println("#" + t + " " + Math.round(totalCost));
		}
	}
	
	private static void makeSet(int n) {	
		for (int i = 0; i < n; i++) {
			parent[i] = i;
		}
	}
	
	private static int find(int a) {
		if (parent[a] == a) {
			return a;
		}
		return parent[a] = find(parent[a]);
	}
	
	private static boolean union(int a, int b) {
		int aRoot = find(a);
		int bRoot = find(b);
		
		if (aRoot == bRoot) {
			return false;
		}
		
		if (aRoot > bRoot) {
			parent[bRoot] = aRoot; 
		} else {
			parent[aRoot] = bRoot;
		}
		
		return true;
	}
	
	// 환경 부담금 계산.
	// 환경 부담 세율(E)과 각 해저터널 길이(L)의 제곱의 곱(E * L^2)만큼 지불
	private static double calculationCost(int[] islandA, int[] islandB) {
		long dx = islandA[0] - islandB[0];
	    long dy = islandA[1] - islandB[1];
	    
	    return E * (dx * dx + dy * dy); 
	}
}
```